[INFO] Scanning for projects...
[INFO] 
[INFO] Using the builder org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder with a thread count of 1
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Closure Maven Plugin Sample Usage 1.0.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-enforcer-plugin:1.3.1:enforce (enforce-versions) @ closure-maven-plugin-test ---
[INFO] 
[INFO] --- closure-maven-plugin:1.0.0-SNAPSHOT:war-extractor (import-dependent-library) @ closure-maven-plugin-test ---
[INFO] 
[INFO] --- closure-maven-plugin:1.0.0-SNAPSHOT:dependency-writer (generate-dependent-js) @ closure-maven-plugin-test ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2.157 s
[INFO] Finished at: 2014-04-01T23:35:42-08:00
[INFO] Final Memory: 9M/171M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal com.poreomix:closure-maven-plugin:1.0.0-SNAPSHOT:dependency-writer (generate-dependent-js) on project closure-maven-plugin-test: A cycle is detected in the dependency tree.[goog.array, goog.array.ArrayLike]goog.array:// Copyright 2006 The Closure Library Authors. All Rights Reserved.
[ERROR] //
[ERROR] // Licensed under the Apache License, Version 2.0 (the "License");
[ERROR] // you may not use this file except in compliance with the License.
[ERROR] // You may obtain a copy of the License at
[ERROR] //
[ERROR] //      http://www.apache.org/licenses/LICENSE-2.0
[ERROR] //
[ERROR] // Unless required by applicable law or agreed to in writing, software
[ERROR] // distributed under the License is distributed on an "AS-IS" BASIS,
[ERROR] // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
[ERROR] // See the License for the specific language governing permissions and
[ERROR] // limitations under the License.
[ERROR] 
[ERROR] /**
[ERROR] * @fileoverview Utilities for manipulating arrays.
[ERROR] *
[ERROR] */
[ERROR] 
[ERROR] 
[ERROR] goog.provide('goog.array');
[ERROR] goog.provide('goog.array.ArrayLike');
[ERROR] 
[ERROR] goog.require('goog.asserts');
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
[ERROR] * rely on Array.prototype functions, if available.
[ERROR] *
[ERROR] * The Array.prototype functions can be defined by external libraries like
[ERROR] * Prototype and setting this flag to false forces closure to use its own
[ERROR] * goog.array implementation.
[ERROR] *
[ERROR] * If your javascript can be loaded by a third party site and you are wary about
[ERROR] * relying on the prototype functions, specify
[ERROR] * "--define goog.NATIVE_ARRAY_PROTOTYPES=false" to the JSCompiler.
[ERROR] *
[ERROR] * Setting goog.TRUSTED_SITE to false will automatically set
[ERROR] * NATIVE_ARRAY_PROTOTYPES to false.
[ERROR] */
[ERROR] goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * @typedef {Array|NodeList|Arguments|{length: number}}
[ERROR] */
[ERROR] goog.array.ArrayLike;
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Returns the last element in an array without removing it.
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} array The array.
[ERROR] * @return {T} Last item in array.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.peek = function(array) {
[ERROR] return array[array.length - 1];
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Reference to the original {@code Array.prototype}.
[ERROR] * @private
[ERROR] */
[ERROR] goog.array.ARRAY_PROTOTYPE_ = Array.prototype;
[ERROR] 
[ERROR] 
[ERROR] // NOTE(arv): Since most of the array functions are generic it allows you to
[ERROR] // pass an array-like object. Strings have a length and are considered array-
[ERROR] // like. However, the 'in' operator does not work on strings so we cannot just
[ERROR] // use the array path even if the browser supports indexing into strings. We
[ERROR] // therefore end up splitting the string.
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Returns the index of the first element of an array with a specified value, or
[ERROR] * -1 if the element is not present in the array.
[ERROR] *
[ERROR] * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr The array to be searched.
[ERROR] * @param {T} obj The object for which we are searching.
[ERROR] * @param {number=} opt_fromIndex The index at which to start the search. If
[ERROR] *     omitted the search starts at index 0.
[ERROR] * @return {number} The index of the first matching array element.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
[ERROR] goog.array.ARRAY_PROTOTYPE_.indexOf ?
[ERROR] function(arr, obj, opt_fromIndex) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] return goog.array.ARRAY_PROTOTYPE_.indexOf.call(arr, obj, opt_fromIndex);
[ERROR] } :
[ERROR] function(arr, obj, opt_fromIndex) {
[ERROR] var fromIndex = opt_fromIndex == null ?
[ERROR] 0 : (opt_fromIndex < 0 ?
[ERROR] Math.max(0, arr.length + opt_fromIndex) : opt_fromIndex);
[ERROR] 
[ERROR] if (goog.isString(arr)) {
[ERROR] // Array.prototype.indexOf uses === so only strings should be found.
[ERROR] if (!goog.isString(obj) || obj.length != 1) {
[ERROR] return -1;
[ERROR] }
[ERROR] return arr.indexOf(obj, fromIndex);
[ERROR] }
[ERROR] 
[ERROR] for (var i = fromIndex; i < arr.length; i++) {
[ERROR] if (i in arr && arr[i] === obj)
[ERROR] return i;
[ERROR] }
[ERROR] return -1;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Returns the index of the last element of an array with a specified value, or
[ERROR] * -1 if the element is not present in the array.
[ERROR] *
[ERROR] * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}
[ERROR] *
[ERROR] * @param {!Array.<T>|!goog.array.ArrayLike} arr The array to be searched.
[ERROR] * @param {T} obj The object for which we are searching.
[ERROR] * @param {?number=} opt_fromIndex The index at which to start the search. If
[ERROR] *     omitted the search starts at the end of the array.
[ERROR] * @return {number} The index of the last matching array element.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
[ERROR] goog.array.ARRAY_PROTOTYPE_.lastIndexOf ?
[ERROR] function(arr, obj, opt_fromIndex) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] // Firefox treats undefined and null as 0 in the fromIndex argument which
[ERROR] // leads it to always return -1
[ERROR] var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
[ERROR] return goog.array.ARRAY_PROTOTYPE_.lastIndexOf.call(arr, obj, fromIndex);
[ERROR] } :
[ERROR] function(arr, obj, opt_fromIndex) {
[ERROR] var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
[ERROR] 
[ERROR] if (fromIndex < 0) {
[ERROR] fromIndex = Math.max(0, arr.length + fromIndex);
[ERROR] }
[ERROR] 
[ERROR] if (goog.isString(arr)) {
[ERROR] // Array.prototype.lastIndexOf uses === so only strings should be found.
[ERROR] if (!goog.isString(obj) || obj.length != 1) {
[ERROR] return -1;
[ERROR] }
[ERROR] return arr.lastIndexOf(obj, fromIndex);
[ERROR] }
[ERROR] 
[ERROR] for (var i = fromIndex; i >= 0; i--) {
[ERROR] if (i in arr && arr[i] === obj)
[ERROR] return i;
[ERROR] }
[ERROR] return -1;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Calls a function for each element in an array. Skips holes in the array.
[ERROR] * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array like object over
[ERROR] *     which to iterate.
[ERROR] * @param {?function(this: S, T, number, ?): ?} f The function to call for every
[ERROR] *     element. This function takes 3 arguments (the element, the index and the
[ERROR] *     array). The return value is ignored.
[ERROR] * @param {S=} opt_obj The object to be used as the value of 'this' within f.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &&
[ERROR] goog.array.ARRAY_PROTOTYPE_.forEach ?
[ERROR] function(arr, f, opt_obj) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] goog.array.ARRAY_PROTOTYPE_.forEach.call(arr, f, opt_obj);
[ERROR] } :
[ERROR] function(arr, f, opt_obj) {
[ERROR] var l = arr.length;  // must be fixed during loop... see docs
[ERROR] var arr2 = goog.isString(arr) ? arr.split('') : arr;
[ERROR] for (var i = 0; i < l; i++) {
[ERROR] if (i in arr2) {
[ERROR] f.call(opt_obj, arr2[i], i, arr);
[ERROR] }
[ERROR] }
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Calls a function for each element in an array, starting from the last
[ERROR] * element rather than the first.
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this: S, T, number, ?): ?} f The function to call for every
[ERROR] *     element. This function
[ERROR] *     takes 3 arguments (the element, the index and the array). The return
[ERROR] *     value is ignored.
[ERROR] * @param {S=} opt_obj The object to be used as the value of 'this'
[ERROR] *     within f.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.forEachRight = function(arr, f, opt_obj) {
[ERROR] var l = arr.length;  // must be fixed during loop... see docs
[ERROR] var arr2 = goog.isString(arr) ? arr.split('') : arr;
[ERROR] for (var i = l - 1; i >= 0; --i) {
[ERROR] if (i in arr2) {
[ERROR] f.call(opt_obj, arr2[i], i, arr);
[ERROR] }
[ERROR] }
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Calls a function for each element in an array, and if the function returns
[ERROR] * true adds the element to a new array.
[ERROR] *
[ERROR] * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, T, number, ?):boolean} f The function to call for
[ERROR] *     every element. This function
[ERROR] *     takes 3 arguments (the element, the index and the array) and must
[ERROR] *     return a Boolean. If the return value is true the element is added to the
[ERROR] *     result array. If it is false the element is not included.
[ERROR] * @param {S=} opt_obj The object to be used as the value of 'this'
[ERROR] *     within f.
[ERROR] * @return {!Array.<T>} a new array in which only elements that passed the test
[ERROR] *     are present.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &&
[ERROR] goog.array.ARRAY_PROTOTYPE_.filter ?
[ERROR] function(arr, f, opt_obj) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] return goog.array.ARRAY_PROTOTYPE_.filter.call(arr, f, opt_obj);
[ERROR] } :
[ERROR] function(arr, f, opt_obj) {
[ERROR] var l = arr.length;  // must be fixed during loop... see docs
[ERROR] var res = [];
[ERROR] var resLength = 0;
[ERROR] var arr2 = goog.isString(arr) ? arr.split('') : arr;
[ERROR] for (var i = 0; i < l; i++) {
[ERROR] if (i in arr2) {
[ERROR] var val = arr2[i];  // in case f mutates arr2
[ERROR] if (f.call(opt_obj, val, i, arr)) {
[ERROR] res[resLength++] = val;
[ERROR] }
[ERROR] }
[ERROR] }
[ERROR] return res;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Calls a function for each element in an array and inserts the result into a
[ERROR] * new array.
[ERROR] *
[ERROR] * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, T, number, ?):?} f The function to call for every
[ERROR] *     element. This function
[ERROR] *     takes 3 arguments (the element, the index and the array) and should
[ERROR] *     return something. The result will be inserted into a new array.
[ERROR] * @param {S=} opt_obj The object to be used as the value of 'this'
[ERROR] *     within f.
[ERROR] * @return {!Array} a new array with the results from f.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &&
[ERROR] goog.array.ARRAY_PROTOTYPE_.map ?
[ERROR] function(arr, f, opt_obj) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] return goog.array.ARRAY_PROTOTYPE_.map.call(arr, f, opt_obj);
[ERROR] } :
[ERROR] function(arr, f, opt_obj) {
[ERROR] var l = arr.length;  // must be fixed during loop... see docs
[ERROR] var res = new Array(l);
[ERROR] var arr2 = goog.isString(arr) ? arr.split('') : arr;
[ERROR] for (var i = 0; i < l; i++) {
[ERROR] if (i in arr2) {
[ERROR] res[i] = f.call(opt_obj, arr2[i], i, arr);
[ERROR] }
[ERROR] }
[ERROR] return res;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Passes every element of an array into a function and accumulates the result.
[ERROR] *
[ERROR] * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}
[ERROR] *
[ERROR] * For example:
[ERROR] * var a = [1, 2, 3, 4];
[ERROR] * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);
[ERROR] * returns 10
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
[ERROR] *     every element. This function
[ERROR] *     takes 4 arguments (the function's previous result or the initial value,
[ERROR] *     the value of the current array element, the current array index, and the
[ERROR] *     array itself)
[ERROR] *     function(previousValue, currentValue, index, array).
[ERROR] * @param {?} val The initial value to pass into the function on the first call.
[ERROR] * @param {S=} opt_obj  The object to be used as the value of 'this'
[ERROR] *     within f.
[ERROR] * @return {R} Result of evaluating f repeatedly across the values of the array.
[ERROR] * @template T,S,R
[ERROR] */
[ERROR] goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES &&
[ERROR] goog.array.ARRAY_PROTOTYPE_.reduce ?
[ERROR] function(arr, f, val, opt_obj) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] if (opt_obj) {
[ERROR] f = goog.bind(f, opt_obj);
[ERROR] }
[ERROR] return goog.array.ARRAY_PROTOTYPE_.reduce.call(arr, f, val);
[ERROR] } :
[ERROR] function(arr, f, val, opt_obj) {
[ERROR] var rval = val;
[ERROR] goog.array.forEach(arr, function(val, index) {
[ERROR] rval = f.call(opt_obj, rval, val, index, arr);
[ERROR] });
[ERROR] return rval;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Passes every element of an array into a function and accumulates the result,
[ERROR] * starting from the last element and working towards the first.
[ERROR] *
[ERROR] * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}
[ERROR] *
[ERROR] * For example:
[ERROR] * var a = ['a', 'b', 'c'];
[ERROR] * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, '');
[ERROR] * returns 'cba'
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
[ERROR] *     every element. This function
[ERROR] *     takes 4 arguments (the function's previous result or the initial value,
[ERROR] *     the value of the current array element, the current array index, and the
[ERROR] *     array itself)
[ERROR] *     function(previousValue, currentValue, index, array).
[ERROR] * @param {?} val The initial value to pass into the function on the first call.
[ERROR] * @param {S=} opt_obj The object to be used as the value of 'this'
[ERROR] *     within f.
[ERROR] * @return {R} Object returned as a result of evaluating f repeatedly across the
[ERROR] *     values of the array.
[ERROR] * @template T,S,R
[ERROR] */
[ERROR] goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &&
[ERROR] goog.array.ARRAY_PROTOTYPE_.reduceRight ?
[ERROR] function(arr, f, val, opt_obj) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] if (opt_obj) {
[ERROR] f = goog.bind(f, opt_obj);
[ERROR] }
[ERROR] return goog.array.ARRAY_PROTOTYPE_.reduceRight.call(arr, f, val);
[ERROR] } :
[ERROR] function(arr, f, val, opt_obj) {
[ERROR] var rval = val;
[ERROR] goog.array.forEachRight(arr, function(val, index) {
[ERROR] rval = f.call(opt_obj, rval, val, index, arr);
[ERROR] });
[ERROR] return rval;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Calls f for each element of an array. If any call returns true, some()
[ERROR] * returns true (without checking the remaining elements). If all calls
[ERROR] * return false, some() returns false.
[ERROR] *
[ERROR] * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
[ERROR] *     for every element. This function takes 3 arguments (the element, the
[ERROR] *     index and the array) and should return a boolean.
[ERROR] * @param {S=} opt_obj  The object to be used as the value of 'this'
[ERROR] *     within f.
[ERROR] * @return {boolean} true if any element passes the test.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &&
[ERROR] goog.array.ARRAY_PROTOTYPE_.some ?
[ERROR] function(arr, f, opt_obj) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] return goog.array.ARRAY_PROTOTYPE_.some.call(arr, f, opt_obj);
[ERROR] } :
[ERROR] function(arr, f, opt_obj) {
[ERROR] var l = arr.length;  // must be fixed during loop... see docs
[ERROR] var arr2 = goog.isString(arr) ? arr.split('') : arr;
[ERROR] for (var i = 0; i < l; i++) {
[ERROR] if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
[ERROR] return true;
[ERROR] }
[ERROR] }
[ERROR] return false;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Call f for each element of an array. If all calls return true, every()
[ERROR] * returns true. If any call returns false, every() returns false and
[ERROR] * does not continue to check the remaining elements.
[ERROR] *
[ERROR] * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
[ERROR] *     for every element. This function takes 3 arguments (the element, the
[ERROR] *     index and the array) and should return a boolean.
[ERROR] * @param {S=} opt_obj The object to be used as the value of 'this'
[ERROR] *     within f.
[ERROR] * @return {boolean} false if any element fails the test.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &&
[ERROR] goog.array.ARRAY_PROTOTYPE_.every ?
[ERROR] function(arr, f, opt_obj) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] return goog.array.ARRAY_PROTOTYPE_.every.call(arr, f, opt_obj);
[ERROR] } :
[ERROR] function(arr, f, opt_obj) {
[ERROR] var l = arr.length;  // must be fixed during loop... see docs
[ERROR] var arr2 = goog.isString(arr) ? arr.split('') : arr;
[ERROR] for (var i = 0; i < l; i++) {
[ERROR] if (i in arr2 && !f.call(opt_obj, arr2[i], i, arr)) {
[ERROR] return false;
[ERROR] }
[ERROR] }
[ERROR] return true;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Counts the array elements that fulfill the predicate, i.e. for which the
[ERROR] * callback function returns true. Skips holes in the array.
[ERROR] *
[ERROR] * @param {!(Array.<T>|goog.array.ArrayLike)} arr Array or array like object
[ERROR] *     over which to iterate.
[ERROR] * @param {function(this: S, T, number, ?): boolean} f The function to call for
[ERROR] *     every element. Takes 3 arguments (the element, the index and the array).
[ERROR] * @param {S=} opt_obj The object to be used as the value of 'this' within f.
[ERROR] * @return {number} The number of the matching elements.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.count = function(arr, f, opt_obj) {
[ERROR] var count = 0;
[ERROR] goog.array.forEach(arr, function(element, index, arr) {
[ERROR] if (f.call(opt_obj, element, index, arr)) {
[ERROR] ++count;
[ERROR] }
[ERROR] }, opt_obj);
[ERROR] return count;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Search an array for the first element that satisfies a given condition and
[ERROR] * return that element.
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, T, number, ?) : boolean} f The function to call
[ERROR] *     for every element. This function takes 3 arguments (the element, the
[ERROR] *     index and the array) and should return a boolean.
[ERROR] * @param {S=} opt_obj An optional "this" context for the function.
[ERROR] * @return {T} The first array element that passes the test, or null if no
[ERROR] *     element is found.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.find = function(arr, f, opt_obj) {
[ERROR] var i = goog.array.findIndex(arr, f, opt_obj);
[ERROR] return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Search an array for the first element that satisfies a given condition and
[ERROR] * return its index.
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
[ERROR] *     every element. This function
[ERROR] *     takes 3 arguments (the element, the index and the array) and should
[ERROR] *     return a boolean.
[ERROR] * @param {S=} opt_obj An optional "this" context for the function.
[ERROR] * @return {number} The index of the first array element that passes the test,
[ERROR] *     or -1 if no element is found.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.findIndex = function(arr, f, opt_obj) {
[ERROR] var l = arr.length;  // must be fixed during loop... see docs
[ERROR] var arr2 = goog.isString(arr) ? arr.split('') : arr;
[ERROR] for (var i = 0; i < l; i++) {
[ERROR] if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
[ERROR] return i;
[ERROR] }
[ERROR] }
[ERROR] return -1;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Search an array (in reverse order) for the last element that satisfies a
[ERROR] * given condition and return that element.
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, T, number, ?) : boolean} f The function to call
[ERROR] *     for every element. This function
[ERROR] *     takes 3 arguments (the element, the index and the array) and should
[ERROR] *     return a boolean.
[ERROR] * @param {S=} opt_obj An optional "this" context for the function.
[ERROR] * @return {T} The last array element that passes the test, or null if no
[ERROR] *     element is found.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.findRight = function(arr, f, opt_obj) {
[ERROR] var i = goog.array.findIndexRight(arr, f, opt_obj);
[ERROR] return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Search an array (in reverse order) for the last element that satisfies a
[ERROR] * given condition and return its index.
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, T, number, ?) : boolean} f The function to call
[ERROR] *     for every element. This function
[ERROR] *     takes 3 arguments (the element, the index and the array) and should
[ERROR] *     return a boolean.
[ERROR] * @param {Object=} opt_obj An optional "this" context for the function.
[ERROR] * @return {number} The index of the last array element that passes the test,
[ERROR] *     or -1 if no element is found.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.findIndexRight = function(arr, f, opt_obj) {
[ERROR] var l = arr.length;  // must be fixed during loop... see docs
[ERROR] var arr2 = goog.isString(arr) ? arr.split('') : arr;
[ERROR] for (var i = l - 1; i >= 0; i--) {
[ERROR] if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
[ERROR] return i;
[ERROR] }
[ERROR] }
[ERROR] return -1;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Whether the array contains the given object.
[ERROR] * @param {goog.array.ArrayLike} arr The array to test for the presence of the
[ERROR] *     element.
[ERROR] * @param {*} obj The object for which to test.
[ERROR] * @return {boolean} true if obj is present.
[ERROR] */
[ERROR] goog.array.contains = function(arr, obj) {
[ERROR] return goog.array.indexOf(arr, obj) >= 0;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Whether the array is empty.
[ERROR] * @param {goog.array.ArrayLike} arr The array to test.
[ERROR] * @return {boolean} true if empty.
[ERROR] */
[ERROR] goog.array.isEmpty = function(arr) {
[ERROR] return arr.length == 0;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Clears the array.
[ERROR] * @param {goog.array.ArrayLike} arr Array or array like object to clear.
[ERROR] */
[ERROR] goog.array.clear = function(arr) {
[ERROR] // For non real arrays we don't have the magic length so we delete the
[ERROR] // indices.
[ERROR] if (!goog.isArray(arr)) {
[ERROR] for (var i = arr.length - 1; i >= 0; i--) {
[ERROR] delete arr[i];
[ERROR] }
[ERROR] }
[ERROR] arr.length = 0;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Pushes an item into an array, if it's not already in the array.
[ERROR] * @param {Array.<T>} arr Array into which to insert the item.
[ERROR] * @param {T} obj Value to add.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.insert = function(arr, obj) {
[ERROR] if (!goog.array.contains(arr, obj)) {
[ERROR] arr.push(obj);
[ERROR] }
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Inserts an object at the given index of the array.
[ERROR] * @param {goog.array.ArrayLike} arr The array to modify.
[ERROR] * @param {*} obj The object to insert.
[ERROR] * @param {number=} opt_i The index at which to insert the object. If omitted,
[ERROR] *      treated as 0. A negative index is counted from the end of the array.
[ERROR] */
[ERROR] goog.array.insertAt = function(arr, obj, opt_i) {
[ERROR] goog.array.splice(arr, opt_i, 0, obj);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Inserts at the given index of the array, all elements of another array.
[ERROR] * @param {goog.array.ArrayLike} arr The array to modify.
[ERROR] * @param {goog.array.ArrayLike} elementsToAdd The array of elements to add.
[ERROR] * @param {number=} opt_i The index at which to insert the object. If omitted,
[ERROR] *      treated as 0. A negative index is counted from the end of the array.
[ERROR] */
[ERROR] goog.array.insertArrayAt = function(arr, elementsToAdd, opt_i) {
[ERROR] goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Inserts an object into an array before a specified object.
[ERROR] * @param {Array.<T>} arr The array to modify.
[ERROR] * @param {T} obj The object to insert.
[ERROR] * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2
[ERROR] *     is omitted or not found, obj is inserted at the end of the array.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.insertBefore = function(arr, obj, opt_obj2) {
[ERROR] var i;
[ERROR] if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) {
[ERROR] arr.push(obj);
[ERROR] } else {
[ERROR] goog.array.insertAt(arr, obj, i);
[ERROR] }
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Removes the first occurrence of a particular value from an array.
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array from which to remove
[ERROR] *     value.
[ERROR] * @param {T} obj Object to remove.
[ERROR] * @return {boolean} True if an element was removed.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.remove = function(arr, obj) {
[ERROR] var i = goog.array.indexOf(arr, obj);
[ERROR] var rv;
[ERROR] if ((rv = i >= 0)) {
[ERROR] goog.array.removeAt(arr, i);
[ERROR] }
[ERROR] return rv;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Removes from an array the element at index i
[ERROR] * @param {goog.array.ArrayLike} arr Array or array like object from which to
[ERROR] *     remove value.
[ERROR] * @param {number} i The index to remove.
[ERROR] * @return {boolean} True if an element was removed.
[ERROR] */
[ERROR] goog.array.removeAt = function(arr, i) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] // use generic form of splice
[ERROR] // splice returns the removed items and if successful the length of that
[ERROR] // will be 1
[ERROR] return goog.array.ARRAY_PROTOTYPE_.splice.call(arr, i, 1).length == 1;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Removes the first value that satisfies the given condition.
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
[ERROR] *     like object over which to iterate.
[ERROR] * @param {?function(this:S, T, number, ?) : boolean} f The function to call
[ERROR] *     for every element. This function
[ERROR] *     takes 3 arguments (the element, the index and the array) and should
[ERROR] *     return a boolean.
[ERROR] * @param {S=} opt_obj An optional "this" context for the function.
[ERROR] * @return {boolean} True if an element was removed.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.removeIf = function(arr, f, opt_obj) {
[ERROR] var i = goog.array.findIndex(arr, f, opt_obj);
[ERROR] if (i >= 0) {
[ERROR] goog.array.removeAt(arr, i);
[ERROR] return true;
[ERROR] }
[ERROR] return false;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Returns a new array that is the result of joining the arguments.  If arrays
[ERROR] * are passed then their items are added, however, if non-arrays are passed they
[ERROR] * will be added to the return array as is.
[ERROR] *
[ERROR] * Note that ArrayLike objects will be added as is, rather than having their
[ERROR] * items added.
[ERROR] *
[ERROR] * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
[ERROR] * goog.array.concat(0, [1, 2]) -> [0, 1, 2]
[ERROR] * goog.array.concat([1, 2], null) -> [1, 2, null]
[ERROR] *
[ERROR] * There is bug in all current versions of IE (6, 7 and 8) where arrays created
[ERROR] * in an iframe become corrupted soon (not immediately) after the iframe is
[ERROR] * destroyed. This is common if loading data via goog.net.IframeIo, for example.
[ERROR] * This corruption only affects the concat method which will start throwing
[ERROR] * Catastrophic Errors (#-2147418113).
[ERROR] *
[ERROR] * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.
[ERROR] *
[ERROR] * Internally goog.array should use this, so that all methods will continue to
[ERROR] * work on these broken array objects.
[ERROR] *
[ERROR] * @param {...*} var_args Items to concatenate.  Arrays will have each item
[ERROR] *     added, while primitives and objects will be added as is.
[ERROR] * @return {!Array} The new resultant array.
[ERROR] */
[ERROR] goog.array.concat = function(var_args) {
[ERROR] return goog.array.ARRAY_PROTOTYPE_.concat.apply(
[ERROR] goog.array.ARRAY_PROTOTYPE_, arguments);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Converts an object to an array.
[ERROR] * @param {goog.array.ArrayLike} object  The object to convert to an array.
[ERROR] * @return {!Array} The object converted into an array. If object has a
[ERROR] *     length property, every property indexed with a non-negative number
[ERROR] *     less than length will be included in the result. If object does not
[ERROR] *     have a length property, an empty array will be returned.
[ERROR] */
[ERROR] goog.array.toArray = function(object) {
[ERROR] var length = object.length;
[ERROR] 
[ERROR] // If length is not a number the following it false. This case is kept for
[ERROR] // backwards compatibility since there are callers that pass objects that are
[ERROR] // not array like.
[ERROR] if (length > 0) {
[ERROR] var rv = new Array(length);
[ERROR] for (var i = 0; i < length; i++) {
[ERROR] rv[i] = object[i];
[ERROR] }
[ERROR] return rv;
[ERROR] }
[ERROR] return [];
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Does a shallow copy of an array.
[ERROR] * @param {goog.array.ArrayLike} arr  Array or array-like object to clone.
[ERROR] * @return {!Array} Clone of the input array.
[ERROR] */
[ERROR] goog.array.clone = goog.array.toArray;
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Extends an array with another array, element, or "array like" object.
[ERROR] * This function operates 'in-place', it does not create a new Array.
[ERROR] *
[ERROR] * Example:
[ERROR] * var a = [];
[ERROR] * goog.array.extend(a, [0, 1]);
[ERROR] * a; // [0, 1]
[ERROR] * goog.array.extend(a, 2);
[ERROR] * a; // [0, 1, 2]
[ERROR] *
[ERROR] * @param {Array} arr1  The array to modify.
[ERROR] * @param {...*} var_args The elements or arrays of elements to add to arr1.
[ERROR] */
[ERROR] goog.array.extend = function(arr1, var_args) {
[ERROR] for (var i = 1; i < arguments.length; i++) {
[ERROR] var arr2 = arguments[i];
[ERROR] // If we have an Array or an Arguments object we can just call push
[ERROR] // directly.
[ERROR] var isArrayLike;
[ERROR] if (goog.isArray(arr2) ||
[ERROR] // Detect Arguments. ES5 says that the [[Class]] of an Arguments object
[ERROR] // is "Arguments" but only V8 and JSC/Safari gets this right. We instead
[ERROR] // detect Arguments by checking for array like and presence of "callee".
[ERROR] (isArrayLike = goog.isArrayLike(arr2)) &&
[ERROR] // The getter for callee throws an exception in strict mode
[ERROR] // according to section 10.6 in ES5 so check for presence instead.
[ERROR] Object.prototype.hasOwnProperty.call(arr2, 'callee')) {
[ERROR] arr1.push.apply(arr1, arr2);
[ERROR] } else if (isArrayLike) {
[ERROR] // Otherwise loop over arr2 to prevent copying the object.
[ERROR] var len1 = arr1.length;
[ERROR] var len2 = arr2.length;
[ERROR] for (var j = 0; j < len2; j++) {
[ERROR] arr1[len1 + j] = arr2[j];
[ERROR] }
[ERROR] } else {
[ERROR] arr1.push(arr2);
[ERROR] }
[ERROR] }
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Adds or removes elements from an array. This is a generic version of Array
[ERROR] * splice. This means that it might work on other objects similar to arrays,
[ERROR] * such as the arguments object.
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr The array to modify.
[ERROR] * @param {number|undefined} index The index at which to start changing the
[ERROR] *     array. If not defined, treated as 0.
[ERROR] * @param {number} howMany How many elements to remove (0 means no removal. A
[ERROR] *     value below 0 is treated as zero and so is any other non number. Numbers
[ERROR] *     are floored).
[ERROR] * @param {...T} var_args Optional, additional elements to insert into the
[ERROR] *     array.
[ERROR] * @return {!Array.<T>} the removed elements.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.splice = function(arr, index, howMany, var_args) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] return goog.array.ARRAY_PROTOTYPE_.splice.apply(
[ERROR] arr, goog.array.slice(arguments, 1));
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Returns a new array from a segment of an array. This is a generic version of
[ERROR] * Array slice. This means that it might work on other objects similar to
[ERROR] * arrays, such as the arguments object.
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr The array from
[ERROR] * which to copy a segment.
[ERROR] * @param {number} start The index of the first element to copy.
[ERROR] * @param {number=} opt_end The index after the last element to copy.
[ERROR] * @return {!Array.<T>} A new array containing the specified segment of the
[ERROR] *     original array.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.slice = function(arr, start, opt_end) {
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] // passing 1 arg to slice is not the same as passing 2 where the second is
[ERROR] // null or undefined (in that case the second argument is treated as 0).
[ERROR] // we could use slice on the arguments object and then use apply instead of
[ERROR] // testing the length
[ERROR] if (arguments.length <= 2) {
[ERROR] return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start);
[ERROR] } else {
[ERROR] return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start, opt_end);
[ERROR] }
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Removes all duplicates from an array (retaining only the first
[ERROR] * occurrence of each array element).  This function modifies the
[ERROR] * array in place and doesn't change the order of the non-duplicate items.
[ERROR] *
[ERROR] * For objects, duplicates are identified as having the same unique ID as
[ERROR] * defined by {@link goog.getUid}.
[ERROR] *
[ERROR] * Alternatively you can specify a custom hash function that returns a unique
[ERROR] * value for each item in the array it should consider unique.
[ERROR] *
[ERROR] * Runtime: N,
[ERROR] * Worstcase space: 2N (no dupes)
[ERROR] *
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr The array from which to remove
[ERROR] *     duplicates.
[ERROR] * @param {Array=} opt_rv An optional array in which to return the results,
[ERROR] *     instead of performing the removal inplace.  If specified, the original
[ERROR] *     array will remain unchanged.
[ERROR] * @param {function(T):string=} opt_hashFn An optional function to use to
[ERROR] *     apply to every item in the array. This function should return a unique
[ERROR] *     value for each item in the array it should consider unique.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.removeDuplicates = function(arr, opt_rv, opt_hashFn) {
[ERROR] var returnArray = opt_rv || arr;
[ERROR] var defaultHashFn = function(item) {
[ERROR] // Prefix each type with a single character representing the type to
[ERROR] // prevent conflicting keys (e.g. true and 'true').
[ERROR] return goog.isObject(current) ? 'o' + goog.getUid(current) :
[ERROR] (typeof current).charAt(0) + current;
[ERROR] };
[ERROR] var hashFn = opt_hashFn || defaultHashFn;
[ERROR] 
[ERROR] var seen = {}, cursorInsert = 0, cursorRead = 0;
[ERROR] while (cursorRead < arr.length) {
[ERROR] var current = arr[cursorRead++];
[ERROR] var key = hashFn(current);
[ERROR] if (!Object.prototype.hasOwnProperty.call(seen, key)) {
[ERROR] seen[key] = true;
[ERROR] returnArray[cursorInsert++] = current;
[ERROR] }
[ERROR] }
[ERROR] returnArray.length = cursorInsert;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Searches the specified array for the specified target using the binary
[ERROR] * search algorithm.  If no opt_compareFn is specified, elements are compared
[ERROR] * using <code>goog.array.defaultCompare</code>, which compares the elements
[ERROR] * using the built in < and > operators.  This will produce the expected
[ERROR] * behavior for homogeneous arrays of String(s) and Number(s). The array
[ERROR] * specified <b>must</b> be sorted in ascending order (as defined by the
[ERROR] * comparison function).  If the array is not sorted, results are undefined.
[ERROR] * If the array contains multiple instances of the specified target value, any
[ERROR] * of these instances may be found.
[ERROR] *
[ERROR] * Runtime: O(log n)
[ERROR] *
[ERROR] * @param {goog.array.ArrayLike} arr The array to be searched.
[ERROR] * @param {*} target The sought value.
[ERROR] * @param {Function=} opt_compareFn Optional comparison function by which the
[ERROR] *     array is ordered. Should take 2 arguments to compare, and return a
[ERROR] *     negative number, zero, or a positive number depending on whether the
[ERROR] *     first argument is less than, equal to, or greater than the second.
[ERROR] * @return {number} Lowest index of the target value if found, otherwise
[ERROR] *     (-(insertion point) - 1). The insertion point is where the value should
[ERROR] *     be inserted into arr to preserve the sorted property.  Return value >= 0
[ERROR] *     iff target is found.
[ERROR] */
[ERROR] goog.array.binarySearch = function(arr, target, opt_compareFn) {
[ERROR] return goog.array.binarySearch_(arr,
[ERROR] opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */,
[ERROR] target);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Selects an index in the specified array using the binary search algorithm.
[ERROR] * The evaluator receives an element and determines whether the desired index
[ERROR] * is before, at, or after it.  The evaluator must be consistent (formally,
[ERROR] * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)
[ERROR] * must be monotonically non-increasing).
[ERROR] *
[ERROR] * Runtime: O(log n)
[ERROR] *
[ERROR] * @param {goog.array.ArrayLike} arr The array to be searched.
[ERROR] * @param {Function} evaluator Evaluator function that receives 3 arguments
[ERROR] *     (the element, the index and the array). Should return a negative number,
[ERROR] *     zero, or a positive number depending on whether the desired index is
[ERROR] *     before, at, or after the element passed to it.
[ERROR] * @param {Object=} opt_obj The object to be used as the value of 'this'
[ERROR] *     within evaluator.
[ERROR] * @return {number} Index of the leftmost element matched by the evaluator, if
[ERROR] *     such exists; otherwise (-(insertion point) - 1). The insertion point is
[ERROR] *     the index of the first element for which the evaluator returns negative,
[ERROR] *     or arr.length if no such element exists. The return value is non-negative
[ERROR] *     iff a match is found.
[ERROR] */
[ERROR] goog.array.binarySelect = function(arr, evaluator, opt_obj) {
[ERROR] return goog.array.binarySearch_(arr, evaluator, true /* isEvaluator */,
[ERROR] undefined /* opt_target */, opt_obj);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Implementation of a binary search algorithm which knows how to use both
[ERROR] * comparison functions and evaluators. If an evaluator is provided, will call
[ERROR] * the evaluator with the given optional data object, conforming to the
[ERROR] * interface defined in binarySelect. Otherwise, if a comparison function is
[ERROR] * provided, will call the comparison function against the given data object.
[ERROR] *
[ERROR] * This implementation purposefully does not use goog.bind or goog.partial for
[ERROR] * performance reasons.
[ERROR] *
[ERROR] * Runtime: O(log n)
[ERROR] *
[ERROR] * @param {goog.array.ArrayLike} arr The array to be searched.
[ERROR] * @param {Function} compareFn Either an evaluator or a comparison function,
[ERROR] *     as defined by binarySearch and binarySelect above.
[ERROR] * @param {boolean} isEvaluator Whether the function is an evaluator or a
[ERROR] *     comparison function.
[ERROR] * @param {*=} opt_target If the function is a comparison function, then this is
[ERROR] *     the target to binary search for.
[ERROR] * @param {Object=} opt_selfObj If the function is an evaluator, this is an
[ERROR] *    optional this object for the evaluator.
[ERROR] * @return {number} Lowest index of the target value if found, otherwise
[ERROR] *     (-(insertion point) - 1). The insertion point is where the value should
[ERROR] *     be inserted into arr to preserve the sorted property.  Return value >= 0
[ERROR] *     iff target is found.
[ERROR] * @private
[ERROR] */
[ERROR] goog.array.binarySearch_ = function(arr, compareFn, isEvaluator, opt_target,
[ERROR] opt_selfObj) {
[ERROR] var left = 0;  // inclusive
[ERROR] var right = arr.length;  // exclusive
[ERROR] var found;
[ERROR] while (left < right) {
[ERROR] var middle = (left + right) >> 1;
[ERROR] var compareResult;
[ERROR] if (isEvaluator) {
[ERROR] compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
[ERROR] } else {
[ERROR] compareResult = compareFn(opt_target, arr[middle]);
[ERROR] }
[ERROR] if (compareResult > 0) {
[ERROR] left = middle + 1;
[ERROR] } else {
[ERROR] right = middle;
[ERROR] // We are looking for the lowest index so we can't return immediately.
[ERROR] found = !compareResult;
[ERROR] }
[ERROR] }
[ERROR] // left is the index if found, or the insertion point otherwise.
[ERROR] // ~left is a shorthand for -left - 1.
[ERROR] return found ? left : ~left;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Sorts the specified array into ascending order.  If no opt_compareFn is
[ERROR] * specified, elements are compared using
[ERROR] * <code>goog.array.defaultCompare</code>, which compares the elements using
[ERROR] * the built in < and > operators.  This will produce the expected behavior
[ERROR] * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
[ERROR] * but will give unpredictable results for heterogenous lists of strings and
[ERROR] * numbers with different numbers of digits.
[ERROR] *
[ERROR] * This sort is not guaranteed to be stable.
[ERROR] *
[ERROR] * Runtime: Same as <code>Array.prototype.sort</code>
[ERROR] *
[ERROR] * @param {Array.<T>} arr The array to be sorted.
[ERROR] * @param {?function(T,T):number=} opt_compareFn Optional comparison
[ERROR] *     function by which the
[ERROR] *     array is to be ordered. Should take 2 arguments to compare, and return a
[ERROR] *     negative number, zero, or a positive number depending on whether the
[ERROR] *     first argument is less than, equal to, or greater than the second.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.sort = function(arr, opt_compareFn) {
[ERROR] // TODO(arv): Update type annotation since null is not accepted.
[ERROR] goog.asserts.assert(arr.length != null);
[ERROR] 
[ERROR] goog.array.ARRAY_PROTOTYPE_.sort.call(
[ERROR] arr, opt_compareFn || goog.array.defaultCompare);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Sorts the specified array into ascending order in a stable way.  If no
[ERROR] * opt_compareFn is specified, elements are compared using
[ERROR] * <code>goog.array.defaultCompare</code>, which compares the elements using
[ERROR] * the built in < and > operators.  This will produce the expected behavior
[ERROR] * for homogeneous arrays of String(s) and Number(s).
[ERROR] *
[ERROR] * Runtime: Same as <code>Array.prototype.sort</code>, plus an additional
[ERROR] * O(n) overhead of copying the array twice.
[ERROR] *
[ERROR] * @param {Array.<T>} arr The array to be sorted.
[ERROR] * @param {?function(T, T): number=} opt_compareFn Optional comparison function
[ERROR] *     by which the array is to be ordered. Should take 2 arguments to compare,
[ERROR] *     and return a negative number, zero, or a positive number depending on
[ERROR] *     whether the first argument is less than, equal to, or greater than the
[ERROR] *     second.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.stableSort = function(arr, opt_compareFn) {
[ERROR] for (var i = 0; i < arr.length; i++) {
[ERROR] arr[i] = {index: i, value: arr[i]};
[ERROR] }
[ERROR] var valueCompareFn = opt_compareFn || goog.array.defaultCompare;
[ERROR] function stableCompareFn(obj1, obj2) {
[ERROR] return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;
[ERROR] };
[ERROR] goog.array.sort(arr, stableCompareFn);
[ERROR] for (var i = 0; i < arr.length; i++) {
[ERROR] arr[i] = arr[i].value;
[ERROR] }
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Sorts an array of objects by the specified object key and compare
[ERROR] * function. If no compare function is provided, the key values are
[ERROR] * compared in ascending order using <code>goog.array.defaultCompare</code>.
[ERROR] * This won't work for keys that get renamed by the compiler. So use
[ERROR] * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.
[ERROR] * @param {Array.<Object>} arr An array of objects to sort.
[ERROR] * @param {string} key The object key to sort by.
[ERROR] * @param {Function=} opt_compareFn The function to use to compare key
[ERROR] *     values.
[ERROR] */
[ERROR] goog.array.sortObjectsByKey = function(arr, key, opt_compareFn) {
[ERROR] var compare = opt_compareFn || goog.array.defaultCompare;
[ERROR] goog.array.sort(arr, function(a, b) {
[ERROR] return compare(a[key], b[key]);
[ERROR] });
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Tells if the array is sorted.
[ERROR] * @param {!Array.<T>} arr The array.
[ERROR] * @param {?function(T,T):number=} opt_compareFn Function to compare the
[ERROR] *     array elements.
[ERROR] *     Should take 2 arguments to compare, and return a negative number, zero,
[ERROR] *     or a positive number depending on whether the first argument is less
[ERROR] *     than, equal to, or greater than the second.
[ERROR] * @param {boolean=} opt_strict If true no equal elements are allowed.
[ERROR] * @return {boolean} Whether the array is sorted.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.isSorted = function(arr, opt_compareFn, opt_strict) {
[ERROR] var compare = opt_compareFn || goog.array.defaultCompare;
[ERROR] for (var i = 1; i < arr.length; i++) {
[ERROR] var compareResult = compare(arr[i - 1], arr[i]);
[ERROR] if (compareResult > 0 || compareResult == 0 && opt_strict) {
[ERROR] return false;
[ERROR] }
[ERROR] }
[ERROR] return true;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Compares two arrays for equality. Two arrays are considered equal if they
[ERROR] * have the same length and their corresponding elements are equal according to
[ERROR] * the comparison function.
[ERROR] *
[ERROR] * @param {goog.array.ArrayLike} arr1 The first array to compare.
[ERROR] * @param {goog.array.ArrayLike} arr2 The second array to compare.
[ERROR] * @param {Function=} opt_equalsFn Optional comparison function.
[ERROR] *     Should take 2 arguments to compare, and return true if the arguments
[ERROR] *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
[ERROR] *     compares the elements using the built-in '===' operator.
[ERROR] * @return {boolean} Whether the two arrays are equal.
[ERROR] */
[ERROR] goog.array.equals = function(arr1, arr2, opt_equalsFn) {
[ERROR] if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
[ERROR] arr1.length != arr2.length) {
[ERROR] return false;
[ERROR] }
[ERROR] var l = arr1.length;
[ERROR] var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
[ERROR] for (var i = 0; i < l; i++) {
[ERROR] if (!equalsFn(arr1[i], arr2[i])) {
[ERROR] return false;
[ERROR] }
[ERROR] }
[ERROR] return true;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * @deprecated Use {@link goog.array.equals}.
[ERROR] * @param {goog.array.ArrayLike} arr1 See {@link goog.array.equals}.
[ERROR] * @param {goog.array.ArrayLike} arr2 See {@link goog.array.equals}.
[ERROR] * @param {Function=} opt_equalsFn See {@link goog.array.equals}.
[ERROR] * @return {boolean} See {@link goog.array.equals}.
[ERROR] */
[ERROR] goog.array.compare = function(arr1, arr2, opt_equalsFn) {
[ERROR] return goog.array.equals(arr1, arr2, opt_equalsFn);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * 3-way array compare function.
[ERROR] * @param {!goog.array.ArrayLike} arr1 The first array to compare.
[ERROR] * @param {!goog.array.ArrayLike} arr2 The second array to compare.
[ERROR] * @param {?function(?, ?): number=} opt_compareFn Optional comparison function
[ERROR] *     by which the array is to be ordered. Should take 2 arguments to compare,
[ERROR] *     and return a negative number, zero, or a positive number depending on
[ERROR] *     whether the first argument is less than, equal to, or greater than the
[ERROR] *     second.
[ERROR] * @return {number} Negative number, zero, or a positive number depending on
[ERROR] *     whether the first argument is less than, equal to, or greater than the
[ERROR] *     second.
[ERROR] */
[ERROR] goog.array.compare3 = function(arr1, arr2, opt_compareFn) {
[ERROR] var compare = opt_compareFn || goog.array.defaultCompare;
[ERROR] var l = Math.min(arr1.length, arr2.length);
[ERROR] for (var i = 0; i < l; i++) {
[ERROR] var result = compare(arr1[i], arr2[i]);
[ERROR] if (result != 0) {
[ERROR] return result;
[ERROR] }
[ERROR] }
[ERROR] return goog.array.defaultCompare(arr1.length, arr2.length);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Compares its two arguments for order, using the built in < and >
[ERROR] * operators.
[ERROR] * @param {*} a The first object to be compared.
[ERROR] * @param {*} b The second object to be compared.
[ERROR] * @return {number} A negative number, zero, or a positive number as the first
[ERROR] *     argument is less than, equal to, or greater than the second.
[ERROR] */
[ERROR] goog.array.defaultCompare = function(a, b) {
[ERROR] return a > b ? 1 : a < b ? -1 : 0;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Compares its two arguments for equality, using the built in === operator.
[ERROR] * @param {*} a The first object to compare.
[ERROR] * @param {*} b The second object to compare.
[ERROR] * @return {boolean} True if the two arguments are equal, false otherwise.
[ERROR] */
[ERROR] goog.array.defaultCompareEquality = function(a, b) {
[ERROR] return a === b;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Inserts a value into a sorted array. The array is not modified if the
[ERROR] * value is already present.
[ERROR] * @param {Array.<T>} array The array to modify.
[ERROR] * @param {T} value The object to insert.
[ERROR] * @param {?function(T,T):number=} opt_compareFn Optional comparison function by
[ERROR] *     which the
[ERROR] *     array is ordered. Should take 2 arguments to compare, and return a
[ERROR] *     negative number, zero, or a positive number depending on whether the
[ERROR] *     first argument is less than, equal to, or greater than the second.
[ERROR] * @return {boolean} True if an element was inserted.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.binaryInsert = function(array, value, opt_compareFn) {
[ERROR] var index = goog.array.binarySearch(array, value, opt_compareFn);
[ERROR] if (index < 0) {
[ERROR] goog.array.insertAt(array, value, -(index + 1));
[ERROR] return true;
[ERROR] }
[ERROR] return false;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Removes a value from a sorted array.
[ERROR] * @param {Array} array The array to modify.
[ERROR] * @param {*} value The object to remove.
[ERROR] * @param {Function=} opt_compareFn Optional comparison function by which the
[ERROR] *     array is ordered. Should take 2 arguments to compare, and return a
[ERROR] *     negative number, zero, or a positive number depending on whether the
[ERROR] *     first argument is less than, equal to, or greater than the second.
[ERROR] * @return {boolean} True if an element was removed.
[ERROR] */
[ERROR] goog.array.binaryRemove = function(array, value, opt_compareFn) {
[ERROR] var index = goog.array.binarySearch(array, value, opt_compareFn);
[ERROR] return (index >= 0) ? goog.array.removeAt(array, index) : false;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Splits an array into disjoint buckets according to a splitting function.
[ERROR] * @param {Array.<T>} array The array.
[ERROR] * @param {function(this:S, T,number,Array.<T>):?} sorter Function to call for
[ERROR] *     every element.  This takes 3 arguments (the element, the index and the
[ERROR] *     array) and must return a valid object key (a string, number, etc), or
[ERROR] *     undefined, if that object should not be placed in a bucket.
[ERROR] * @param {S=} opt_obj The object to be used as the value of 'this' within
[ERROR] *     sorter.
[ERROR] * @return {!Object} An object, with keys being all of the unique return values
[ERROR] *     of sorter, and values being arrays containing the items for
[ERROR] *     which the splitter returned that key.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.bucket = function(array, sorter, opt_obj) {
[ERROR] var buckets = {};
[ERROR] 
[ERROR] for (var i = 0; i < array.length; i++) {
[ERROR] var value = array[i];
[ERROR] var key = sorter.call(opt_obj, value, i, array);
[ERROR] if (goog.isDef(key)) {
[ERROR] // Push the value to the right bucket, creating it if necessary.
[ERROR] var bucket = buckets[key] || (buckets[key] = []);
[ERROR] bucket.push(value);
[ERROR] }
[ERROR] }
[ERROR] 
[ERROR] return buckets;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Creates a new object built from the provided array and the key-generation
[ERROR] * function.
[ERROR] * @param {Array.<T>|goog.array.ArrayLike} arr Array or array like object over
[ERROR] *     which to iterate whose elements will be the values in the new object.
[ERROR] * @param {?function(this:S, T, number, ?) : string} keyFunc The function to
[ERROR] *     call for every element. This function takes 3 arguments (the element, the
[ERROR] *     index and the array) and should return a string that will be used as the
[ERROR] *     key for the element in the new object. If the function returns the same
[ERROR] *     key for more than one element, the value for that key is
[ERROR] *     implementation-defined.
[ERROR] * @param {S=} opt_obj The object to be used as the value of 'this'
[ERROR] *     within keyFunc.
[ERROR] * @return {!Object.<T>} The new object.
[ERROR] * @template T,S
[ERROR] */
[ERROR] goog.array.toObject = function(arr, keyFunc, opt_obj) {
[ERROR] var ret = {};
[ERROR] goog.array.forEach(arr, function(element, index) {
[ERROR] ret[keyFunc.call(opt_obj, element, index, arr)] = element;
[ERROR] });
[ERROR] return ret;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Creates a range of numbers in an arithmetic progression.
[ERROR] *
[ERROR] * Range takes 1, 2, or 3 arguments:
[ERROR] * <pre>
[ERROR] * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]
[ERROR] * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]
[ERROR] * range(-2, -5, -1) produces [-2, -3, -4]
[ERROR] * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.
[ERROR] * </pre>
[ERROR] *
[ERROR] * @param {number} startOrEnd The starting value of the range if an end argument
[ERROR] *     is provided. Otherwise, the start value is 0, and this is the end value.
[ERROR] * @param {number=} opt_end The optional end value of the range.
[ERROR] * @param {number=} opt_step The step size between range values. Defaults to 1
[ERROR] *     if opt_step is undefined or 0.
[ERROR] * @return {!Array.<number>} An array of numbers for the requested range. May be
[ERROR] *     an empty array if adding the step would not converge toward the end
[ERROR] *     value.
[ERROR] */
[ERROR] goog.array.range = function(startOrEnd, opt_end, opt_step) {
[ERROR] var array = [];
[ERROR] var start = 0;
[ERROR] var end = startOrEnd;
[ERROR] var step = opt_step || 1;
[ERROR] if (opt_end !== undefined) {
[ERROR] start = startOrEnd;
[ERROR] end = opt_end;
[ERROR] }
[ERROR] 
[ERROR] if (step * (end - start) < 0) {
[ERROR] // Sign mismatch: start + step will never reach the end value.
[ERROR] return [];
[ERROR] }
[ERROR] 
[ERROR] if (step > 0) {
[ERROR] for (var i = start; i < end; i += step) {
[ERROR] array.push(i);
[ERROR] }
[ERROR] } else {
[ERROR] for (var i = start; i > end; i += step) {
[ERROR] array.push(i);
[ERROR] }
[ERROR] }
[ERROR] return array;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Returns an array consisting of the given value repeated N times.
[ERROR] *
[ERROR] * @param {*} value The value to repeat.
[ERROR] * @param {number} n The repeat count.
[ERROR] * @return {!Array} An array with the repeated value.
[ERROR] */
[ERROR] goog.array.repeat = function(value, n) {
[ERROR] var array = [];
[ERROR] for (var i = 0; i < n; i++) {
[ERROR] array[i] = value;
[ERROR] }
[ERROR] return array;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Returns an array consisting of every argument with all arrays
[ERROR] * expanded in-place recursively.
[ERROR] *
[ERROR] * @param {...*} var_args The values to flatten.
[ERROR] * @return {!Array} An array containing the flattened values.
[ERROR] */
[ERROR] goog.array.flatten = function(var_args) {
[ERROR] var result = [];
[ERROR] for (var i = 0; i < arguments.length; i++) {
[ERROR] var element = arguments[i];
[ERROR] if (goog.isArray(element)) {
[ERROR] result.push.apply(result, goog.array.flatten.apply(null, element));
[ERROR] } else {
[ERROR] result.push(element);
[ERROR] }
[ERROR] }
[ERROR] return result;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Rotates an array in-place. After calling this method, the element at
[ERROR] * index i will be the element previously at index (i - n) %
[ERROR] * array.length, for all values of i between 0 and array.length - 1,
[ERROR] * inclusive.
[ERROR] *
[ERROR] * For example, suppose list comprises [t, a, n, k, s]. After invoking
[ERROR] * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].
[ERROR] *
[ERROR] * @param {!Array.<T>} array The array to rotate.
[ERROR] * @param {number} n The amount to rotate.
[ERROR] * @return {!Array.<T>} The array.
[ERROR] * @template T
[ERROR] */
[ERROR] goog.array.rotate = function(array, n) {
[ERROR] goog.asserts.assert(array.length != null);
[ERROR] 
[ERROR] if (array.length) {
[ERROR] n %= array.length;
[ERROR] if (n > 0) {
[ERROR] goog.array.ARRAY_PROTOTYPE_.unshift.apply(array, array.splice(-n, n));
[ERROR] } else if (n < 0) {
[ERROR] goog.array.ARRAY_PROTOTYPE_.push.apply(array, array.splice(0, -n));
[ERROR] }
[ERROR] }
[ERROR] return array;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Moves one item of an array to a new position keeping the order of the rest
[ERROR] * of the items. Example use case: keeping a list of JavaScript objects
[ERROR] * synchronized with the corresponding list of DOM elements after one of the
[ERROR] * elements has been dragged to a new position.
[ERROR] * @param {!(Array|Arguments|{length:number})} arr The array to modify.
[ERROR] * @param {number} fromIndex Index of the item to move between 0 and
[ERROR] *     {@code arr.length - 1}.
[ERROR] * @param {number} toIndex Target index between 0 and {@code arr.length - 1}.
[ERROR] */
[ERROR] goog.array.moveItem = function(arr, fromIndex, toIndex) {
[ERROR] goog.asserts.assert(fromIndex >= 0 && fromIndex < arr.length);
[ERROR] goog.asserts.assert(toIndex >= 0 && toIndex < arr.length);
[ERROR] // Remove 1 item at fromIndex.
[ERROR] var removedItems = goog.array.ARRAY_PROTOTYPE_.splice.call(arr, fromIndex, 1);
[ERROR] // Insert the removed item at toIndex.
[ERROR] goog.array.ARRAY_PROTOTYPE_.splice.call(arr, toIndex, 0, removedItems[0]);
[ERROR] // We don't use goog.array.insertAt and goog.array.removeAt, because they're
[ERROR] // significantly slower than splice.
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Creates a new array for which the element at position i is an array of the
[ERROR] * ith element of the provided arrays.  The returned array will only be as long
[ERROR] * as the shortest array provided; additional values are ignored.  For example,
[ERROR] * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].
[ERROR] *
[ERROR] * This is similar to the zip() function in Python.  See {@link
[ERROR] * http://docs.python.org/library/functions.html#zip}
[ERROR] *
[ERROR] * @param {...!goog.array.ArrayLike} var_args Arrays to be combined.
[ERROR] * @return {!Array.<!Array>} A new array of arrays created from provided arrays.
[ERROR] */
[ERROR] goog.array.zip = function(var_args) {
[ERROR] if (!arguments.length) {
[ERROR] return [];
[ERROR] }
[ERROR] var result = [];
[ERROR] for (var i = 0; true; i++) {
[ERROR] var value = [];
[ERROR] for (var j = 0; j < arguments.length; j++) {
[ERROR] var arr = arguments[j];
[ERROR] // If i is larger than the array length, this is the shortest array.
[ERROR] if (i >= arr.length) {
[ERROR] return result;
[ERROR] }
[ERROR] value.push(arr[i]);
[ERROR] }
[ERROR] result.push(value);
[ERROR] }
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Shuffles the values in the specified array using the Fisher-Yates in-place
[ERROR] * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()
[ERROR] * and so resets the state of that random number generator. Similarly, may reset
[ERROR] * the state of the any other specified random number generator.
[ERROR] *
[ERROR] * Runtime: O(n)
[ERROR] *
[ERROR] * @param {!Array} arr The array to be shuffled.
[ERROR] * @param {function():number=} opt_randFn Optional random function to use for
[ERROR] *     shuffling.
[ERROR] *     Takes no arguments, and returns a random number on the interval [0, 1).
[ERROR] *     Defaults to Math.random() using JavaScript's built-in Math library.
[ERROR] */
[ERROR] goog.array.shuffle = function(arr, opt_randFn) {
[ERROR] var randFn = opt_randFn || Math.random;
[ERROR] 
[ERROR] for (var i = arr.length - 1; i > 0; i--) {
[ERROR] // Choose a random array index in [0, i] (inclusive with i).
[ERROR] var j = Math.floor(randFn() * (i + 1));
[ERROR] 
[ERROR] var tmp = arr[i];
[ERROR] arr[i] = arr[j];
[ERROR] arr[j] = tmp;
[ERROR] }
[ERROR] };
[ERROR] :// Copyright 2007 The Closure Library Authors. All Rights Reserved.
[ERROR] //
[ERROR] // Licensed under the Apache License, Version 2.0 (the "License");
[ERROR] // you may not use this file except in compliance with the License.
[ERROR] // You may obtain a copy of the License at
[ERROR] //
[ERROR] //      http://www.apache.org/licenses/LICENSE-2.0
[ERROR] //
[ERROR] // Unless required by applicable law or agreed to in writing, software
[ERROR] // distributed under the License is distributed on an "AS-IS" BASIS,
[ERROR] // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
[ERROR] // See the License for the specific language governing permissions and
[ERROR] // limitations under the License.
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * @fileoverview Utilities for adding, removing and setting ARIA roles and
[ERROR] * states as defined by W3C ARIA standard: http://www.w3.org/TR/wai-aria/
[ERROR] * All modern browsers have some form of ARIA support, so no browser checks are
[ERROR] * performed when adding ARIA to components.
[ERROR] *
[ERROR] */
[ERROR] 
[ERROR] goog.provide('goog.a11y.aria');
[ERROR] 
[ERROR] goog.require('goog.a11y.aria.Role');
[ERROR] goog.require('goog.a11y.aria.State');
[ERROR] goog.require('goog.a11y.aria.datatables');
[ERROR] goog.require('goog.array');
[ERROR] goog.require('goog.asserts');
[ERROR] goog.require('goog.dom');
[ERROR] goog.require('goog.dom.TagName');
[ERROR] goog.require('goog.object');
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * ARIA states/properties prefix.
[ERROR] * @private
[ERROR] */
[ERROR] goog.a11y.aria.ARIA_PREFIX_ = 'aria-';
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * ARIA role attribute.
[ERROR] * @private
[ERROR] */
[ERROR] goog.a11y.aria.ROLE_ATTRIBUTE_ = 'role';
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * A list of tag names for which we don't need to set ARIA role and states
[ERROR] * because they have well supported semantics for screen readers or because
[ERROR] * they don't contain content to be made accessible.
[ERROR] * @private
[ERROR] */
[ERROR] goog.a11y.aria.TAGS_WITH_ASSUMED_ROLES_ = [
[ERROR] goog.dom.TagName.A,
[ERROR] goog.dom.TagName.AREA,
[ERROR] goog.dom.TagName.BUTTON,
[ERROR] goog.dom.TagName.HEAD,
[ERROR] goog.dom.TagName.INPUT,
[ERROR] goog.dom.TagName.LINK,
[ERROR] goog.dom.TagName.MENU,
[ERROR] goog.dom.TagName.META,
[ERROR] goog.dom.TagName.OPTGROUP,
[ERROR] goog.dom.TagName.OPTION,
[ERROR] goog.dom.TagName.PROGRESS,
[ERROR] goog.dom.TagName.STYLE,
[ERROR] goog.dom.TagName.SELECT,
[ERROR] goog.dom.TagName.SOURCE,
[ERROR] goog.dom.TagName.TEXTAREA,
[ERROR] goog.dom.TagName.TITLE,
[ERROR] goog.dom.TagName.TRACK
[ERROR] ];
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Sets the role of an element. If the roleName is
[ERROR] * empty string or null, the role for the element is removed.
[ERROR] * We encourage clients to call the goog.a11y.aria.removeRole
[ERROR] * method instead of setting null and empty string values.
[ERROR] * Special handling for this case is added to ensure
[ERROR] * backword compatibility with existing code.
[ERROR] *
[ERROR] * @param {!Element} element DOM node to set role of.
[ERROR] * @param {!goog.a11y.aria.Role|string} roleName role name(s).
[ERROR] */
[ERROR] goog.a11y.aria.setRole = function(element, roleName) {
[ERROR] if (!roleName) {
[ERROR] // Setting the ARIA role to empty string is not allowed
[ERROR] // by the ARIA standard.
[ERROR] goog.a11y.aria.removeRole(element);
[ERROR] } else {
[ERROR] if (goog.asserts.ENABLE_ASSERTS) {
[ERROR] goog.asserts.assert(goog.object.containsValue(
[ERROR] goog.a11y.aria.Role, roleName), 'No such ARIA role ' + roleName);
[ERROR] }
[ERROR] element.setAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_, roleName);
[ERROR] }
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Gets role of an element.
[ERROR] * @param {!Element} element DOM element to get role of.
[ERROR] * @return {?goog.a11y.aria.Role} ARIA Role name.
[ERROR] */
[ERROR] goog.a11y.aria.getRole = function(element) {
[ERROR] var role = element.getAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_);
[ERROR] return /** @type {goog.a11y.aria.Role} */ (role) || null;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Removes role of an element.
[ERROR] * @param {!Element} element DOM element to remove the role from.
[ERROR] */
[ERROR] goog.a11y.aria.removeRole = function(element) {
[ERROR] element.removeAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Sets the state or property of an element.
[ERROR] * @param {!Element} element DOM node where we set state.
[ERROR] * @param {!(goog.a11y.aria.State|string)} stateName State attribute being set.
[ERROR] *     Automatically adds prefix 'aria-' to the state name if the attribute is
[ERROR] *     not an extra attribute.
[ERROR] * @param {string|boolean|number|!goog.array.ArrayLike.<string>} value Value
[ERROR] * for the state attribute.
[ERROR] */
[ERROR] goog.a11y.aria.setState = function(element, stateName, value) {
[ERROR] if (goog.isArrayLike(value)) {
[ERROR] var array = /** @type {!goog.array.ArrayLike.<string>} */ (value);
[ERROR] value = array.join(' ');
[ERROR] }
[ERROR] var attrStateName = goog.a11y.aria.getAriaAttributeName_(stateName);
[ERROR] if (value === '' || value == undefined) {
[ERROR] var defaultValueMap = goog.a11y.aria.datatables.getDefaultValuesMap();
[ERROR] // Work around for browsers that don't properly support ARIA.
[ERROR] // According to the ARIA W3C standard, user agents should allow
[ERROR] // setting empty value which results in setting the default value
[ERROR] // for the ARIA state if such exists. The exact text from the ARIA W3C
[ERROR] // standard (http://www.w3.org/TR/wai-aria/states_and_properties):
[ERROR] // "When a value is indicated as the default, the user agent
[ERROR] // MUST follow the behavior prescribed by this value when the state or
[ERROR] // property is empty or undefined."
[ERROR] // The defaultValueMap contains the default values for the ARIA states
[ERROR] // and has as a key the goog.a11y.aria.State constant for the state.
[ERROR] if (stateName in defaultValueMap) {
[ERROR] element.setAttribute(attrStateName, defaultValueMap[stateName]);
[ERROR] } else {
[ERROR] element.removeAttribute(attrStateName);
[ERROR] }
[ERROR] } else {
[ERROR] element.setAttribute(attrStateName, value);
[ERROR] }
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Remove the state or property for the element.
[ERROR] * @param {!Element} element DOM node where we set state.
[ERROR] * @param {!goog.a11y.aria.State} stateName State name.
[ERROR] */
[ERROR] goog.a11y.aria.removeState = function(element, stateName) {
[ERROR] element.removeAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Gets value of specified state or property.
[ERROR] * @param {!Element} element DOM node to get state from.
[ERROR] * @param {!goog.a11y.aria.State|string} stateName State name.
[ERROR] * @return {string} Value of the state attribute.
[ERROR] */
[ERROR] goog.a11y.aria.getState = function(element, stateName) {
[ERROR] // TODO(user): return properly typed value result --
[ERROR] // boolean, number, string, null. We should be able to chain
[ERROR] // getState(...) and setState(...) methods.
[ERROR] 
[ERROR] var attr =
[ERROR] /** @type {string|number|boolean} */ (element.getAttribute(
[ERROR] goog.a11y.aria.getAriaAttributeName_(stateName)));
[ERROR] var isNullOrUndefined = attr == null || attr == undefined;
[ERROR] return isNullOrUndefined ? '' : String(attr);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Returns the activedescendant element for the input element by
[ERROR] * using the activedescendant ARIA property of the given element.
[ERROR] * @param {!Element} element DOM node to get activedescendant
[ERROR] *     element for.
[ERROR] * @return {?Element} DOM node of the activedescendant, if found.
[ERROR] */
[ERROR] goog.a11y.aria.getActiveDescendant = function(element) {
[ERROR] var id = goog.a11y.aria.getState(
[ERROR] element, goog.a11y.aria.State.ACTIVEDESCENDANT);
[ERROR] return goog.dom.getOwnerDocument(element).getElementById(id);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Sets the activedescendant ARIA property value for an element.
[ERROR] * If the activeElement is not null, it should have an id set.
[ERROR] * @param {!Element} element DOM node to set activedescendant ARIA property to.
[ERROR] * @param {?Element} activeElement DOM node being set as activedescendant.
[ERROR] */
[ERROR] goog.a11y.aria.setActiveDescendant = function(element, activeElement) {
[ERROR] var id = '';
[ERROR] if (activeElement) {
[ERROR] id = activeElement.id;
[ERROR] goog.asserts.assert(id, 'The active element should have an id.');
[ERROR] }
[ERROR] 
[ERROR] goog.a11y.aria.setState(element, goog.a11y.aria.State.ACTIVEDESCENDANT, id);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Gets the label of the given element.
[ERROR] * @param {!Element} element DOM node to get label from.
[ERROR] * @return {string} label The label.
[ERROR] */
[ERROR] goog.a11y.aria.getLabel = function(element) {
[ERROR] return goog.a11y.aria.getState(element, goog.a11y.aria.State.LABEL);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Sets the label of the given element.
[ERROR] * @param {!Element} element DOM node to set label to.
[ERROR] * @param {string} label The label to set.
[ERROR] */
[ERROR] goog.a11y.aria.setLabel = function(element, label) {
[ERROR] goog.a11y.aria.setState(element, goog.a11y.aria.State.LABEL, label);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Asserts that the element has a role set if it's not an HTML element whose
[ERROR] * semantics is well supported by most screen readers.
[ERROR] * Only to be used internally by the ARIA library in goog.a11y.aria.*.
[ERROR] * @param {!Element} element The element to assert an ARIA role set.
[ERROR] * @param {!goog.array.ArrayLike.<string>} allowedRoles The child roles of
[ERROR] * the roles.
[ERROR] */
[ERROR] goog.a11y.aria.assertRoleIsSetInternalUtil = function(element, allowedRoles) {
[ERROR] if (goog.array.contains(goog.a11y.aria.TAGS_WITH_ASSUMED_ROLES_,
[ERROR] element.tagName)) {
[ERROR] return;
[ERROR] }
[ERROR] var elementRole = /** @type {string}*/ (goog.a11y.aria.getRole(element));
[ERROR] goog.asserts.assert(elementRole != null,
[ERROR] 'The element ARIA role cannot be null.');
[ERROR] 
[ERROR] goog.asserts.assert(goog.array.contains(allowedRoles, elementRole),
[ERROR] 'Non existing or incorrect role set for element.' +
[ERROR] 'The role set is "' + elementRole +
[ERROR] '". The role should be any of "' + allowedRoles +
[ERROR] '". Check the ARIA specification for more details ' +
[ERROR] 'http://www.w3.org/TR/wai-aria/roles.');
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Gets the boolean value of an ARIA state/property.
[ERROR] * @param {!Element} element The element to get the ARIA state for.
[ERROR] * @param {!goog.a11y.aria.State|string} stateName the ARIA state name.
[ERROR] * @return {?boolean} Boolean value for the ARIA state value or null if
[ERROR] *     the state value is not 'true', not 'false', or not set.
[ERROR] */
[ERROR] goog.a11y.aria.getStateBoolean = function(element, stateName) {
[ERROR] var attr =
[ERROR] /** @type {string|boolean} */ (element.getAttribute(
[ERROR] goog.a11y.aria.getAriaAttributeName_(stateName)));
[ERROR] goog.asserts.assert(
[ERROR] goog.isBoolean(attr) || attr == null || attr == 'true' ||
[ERROR] attr == 'false');
[ERROR] if (attr == null) {
[ERROR] return attr;
[ERROR] }
[ERROR] return goog.isBoolean(attr) ? attr : attr == 'true';
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Gets the number value of an ARIA state/property.
[ERROR] * @param {!Element} element The element to get the ARIA state for.
[ERROR] * @param {!goog.a11y.aria.State|string} stateName the ARIA state name.
[ERROR] * @return {?number} Number value for the ARIA state value or null if
[ERROR] *     the state value is not a number or not set.
[ERROR] */
[ERROR] goog.a11y.aria.getStateNumber = function(element, stateName) {
[ERROR] var attr =
[ERROR] /** @type {string|number} */ (element.getAttribute(
[ERROR] goog.a11y.aria.getAriaAttributeName_(stateName)));
[ERROR] goog.asserts.assert((attr == null || !isNaN(Number(attr))) &&
[ERROR] !goog.isBoolean(attr));
[ERROR] return attr == null ? null : Number(attr);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Gets the string value of an ARIA state/property.
[ERROR] * @param {!Element} element The element to get the ARIA state for.
[ERROR] * @param {!goog.a11y.aria.State|string} stateName the ARIA state name.
[ERROR] * @return {?string} String value for the ARIA state value or null if
[ERROR] *     the state value is empty string or not set.
[ERROR] */
[ERROR] goog.a11y.aria.getStateString = function(element, stateName) {
[ERROR] var attr = element.getAttribute(
[ERROR] goog.a11y.aria.getAriaAttributeName_(stateName));
[ERROR] goog.asserts.assert((attr == null || goog.isString(attr)) &&
[ERROR] isNaN(Number(attr)) && attr != 'true' && attr != 'false');
[ERROR] return attr == null ? null : attr;
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Gets array of strings value of the specified state or
[ERROR] * property for the element.
[ERROR] * Only to be used internally by the ARIA library in goog.a11y.aria.*.
[ERROR] * @param {!Element} element DOM node to get state from.
[ERROR] * @param {!goog.a11y.aria.State} stateName State name.
[ERROR] * @return {!goog.array.ArrayLike.<string>} string Array
[ERROR] *     value of the state attribute.
[ERROR] */
[ERROR] goog.a11y.aria.getStringArrayStateInternalUtil = function(element, stateName) {
[ERROR] var attrValue = element.getAttribute(
[ERROR] goog.a11y.aria.getAriaAttributeName_(stateName));
[ERROR] return goog.a11y.aria.splitStringOnWhitespace_(attrValue);
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Splits the input stringValue on whitespace.
[ERROR] * @param {string} stringValue The value of the string to split.
[ERROR] * @return {!goog.array.ArrayLike.<string>} string Array
[ERROR] *     value as result of the split.
[ERROR] * @private
[ERROR] */
[ERROR] goog.a11y.aria.splitStringOnWhitespace_ = function(stringValue) {
[ERROR] return stringValue ? stringValue.split(/\s+/) : [];
[ERROR] };
[ERROR] 
[ERROR] 
[ERROR] /**
[ERROR] * Adds the 'aria-' prefix to ariaName.
[ERROR] * @param {string} ariaName ARIA state/property name.
[ERROR] * @private
[ERROR] * @return {string} The ARIA attribute name with added 'aria-' prefix.
[ERROR] * @throws {Error} If no such attribute exists.
[ERROR] */
[ERROR] goog.a11y.aria.getAriaAttributeName_ = function(ariaName) {
[ERROR] if (goog.asserts.ENABLE_ASSERTS) {
[ERROR] goog.asserts.assert(ariaName, 'ARIA attribute cannot be empty.');
[ERROR] goog.asserts.assert(goog.object.containsValue(
[ERROR] goog.a11y.aria.State, ariaName),
[ERROR] 'No such ARIA attribute ' + ariaName);
[ERROR] }
[ERROR] return goog.a11y.aria.ARIA_PREFIX_ + ariaName;
[ERROR] };
[ERROR] -> [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
